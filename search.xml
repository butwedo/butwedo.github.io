<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Hello, world.]]></title>
      <url>/2017/10/10/Hello/</url>
      <content type="html"><![CDATA[<p>所以，从前天就一直开始搞的这个博客，到今天终于是差不多整好了。真是长舒了一口气。虽然之间发生了很多鬼事，不过谢天谢地到最后所有事都在掌控之中。</p>
<h3 id="非常感谢的一些人："><a href="#非常感谢的一些人：" class="headerlink" title="非常感谢的一些人："></a>非常感谢的一些人：</h3><ul>
<li><a href="https://yzyun.pw" target="_blank" rel="external">yzyun</a> dalao,是比我先整blog的人，也是因为他的影响我才开始有了开博客的念头，在搭建博客的过程中包括关于Hexo模板的种种问题以及域名的购置及解析都帮了我非常非常大的忙。</li>
<li><a href="https://ytoworld.tk" target="_blank" rel="external">yto</a>  貌似是最先有博客的dalao，对一些系统和github的知识非常熟悉并且帮助人时非常亲切<del>大概是因为他是双性恋的原因吧</del></li>
<li>同机房的czd帮我用支付宝付了域名的费用，非常感谢并再一次使我认识到了财政独立的重要性。</li>
<li>HYS dalao，不折不扣的真正巨神，在出题的百忙之余帮没带手机的我用自己的手机完成了一些账号的短信验证。非常感谢他的帮忙并日常膜拜</li>
<li><a href="http://go.kieran.top" target="_blank" rel="external">kieran</a> 并不认识这位大佬，但博客第一个主题是用的这位大牛的<a href="https://github.com/SuperKieran/TKL" target="_blank" rel="external">TKL</a>,并且背景的两只小猫也是TKL原来的背景。虽然因为dalao的使用文档是全英的，蒟蒻根本看不懂，但是页面非常漂亮！如果有哪位也有意想要搭个类似的博客的话，可以考虑一下这位大佬的主题！</li>
<li><a href="https://material.viosey.com/" target="_blank" rel="external">Viosey</a> 这位大佬设计了我现在使用的主题，各方面都非常棒！并且提供了详细的中文说明文档，非常照顾我这种小白！强烈安利！<br>还有这个博客的一些图片，以及搭建过程中一些小问题的解决，都是各位网友前辈留下来的，在这里也要说声谢谢。</li>
</ul>
<hr>
<p>然后，按照惯例:</p>
<p><em>Hello, world.</em></p>
<pre><code class="cpp">#include&lt;iostream&gt;
using namespace std;
int main()
{
    cout&lt;&lt;&quot;Hello, world.&quot;;
    return 0;
}
</code></pre>
<blockquote>
<p><em>They say no one cares, no one sees, no one can get though</em></p>
<p><em>However, as I know I’m not the only one,I say:</em></p>
<p><em>“Well,but we do.</em></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 新世界 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 新世界 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[luogu3545(POI)]]></title>
      <url>/2017/10/10/luogu3545-POI/</url>
      <content type="html"><![CDATA[<p>POI中的水题，我们尽可能多的去满足顾客，直到当前顾客不能被满足，我们就找到之前需求最大的的顾客，然后判断一下与当前顾客谁的需求更大一些，若当前顾客需求大则跳过他，否则踢掉之前需求最大的顾客，来满足当前顾客。这样答案不会变得更差，而且我们还有了更多的货物更有可能满足后来的人。“找到之前需求最大的顾客”我们可以用堆来实现。整个过程时间复杂度为O(nlogn).</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
long long a[250004],b[250005];
long long n;
long long rest;
long long k;
struct dou
{
    long long num,val;
};
bool operator &gt; (dou x,dou y)
{
    return x.val&gt;y.val;
}
bool operator &lt; (dou x,dou y)
{
    return x.val&lt;y.val;
}
priority_queue&lt;dou&gt; q;
long long ans;
bool vis[250005];
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(long long i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    for(long long i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;b[i]);
    dou t;
    for(long long i=1;i&lt;=n;i++)
    {
        rest+=a[i];
        if(rest&gt;=b[i])
        {
            ans++;
            rest-=b[i];
            t.val=b[i];
            t.num=i;
            vis[i]=1;
            q.push(t);
        } 
        else
        {
            if(q.empty())continue;
            t=q.top();
            if(b[i]&gt;=t.val)continue;
            q.pop();
            rest+=t.val;
            rest-=b[i];
            vis[t.num]=0;
            vis[i]=1;
            t.num=i;
            t.val=b[i];
            q.push(t);
        }
    }
    printf(&quot;%d\n&quot;,ans);
    for(long long i=1;i&lt;=n;i++)
        if(vis[i]) printf(&quot;%d &quot;,i);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> luogu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> POI </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[luogu2444(POI)]]></title>
      <url>/2017/10/10/luogu2444-POI/</url>
      <content type="html"><![CDATA[<p>这是一道对于AC自动机很好的一个应用。正常情况下，我们都是希望字符串尽可能的去匹配，这道题则是在匹配完成之前尽可能地转移。于是按照AC自动机的思路我们先建出trie树并构造出fail指针，然后从根开始深搜，如果搜到一个环则我们可以在这个环上不断地构建安全代码，否则无解。在深搜时要注意，我们只能向安全节点（无结束标记的节点）转移。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;
struct trie{
    int nxt[2];
    int fail;
    int nd;
};
int tot;
trie ac[30400];
int n;
char ch[2003];
inline void add(char *c)
{
    int len=strlen(c);
    int k=0;
    for(int i=0;i&lt;len;i++)
    {
        int j=c[i]-&#39;0&#39;;
        if(ac[k].nxt[j]==0)
            ac[k].nxt[j]=++tot;
        k=ac[k].nxt[j];
    }
    ac[k].nd++;
}
inline void find_fail()
{
    queue&lt;int&gt;q;
    int r=0;
    for(int i=0;i&lt;2;i++)
    {
        if(ac[r].nxt[i])q.push(ac[r].nxt[i]);
        ac[ac[r].nxt[i]].fail=0;
    }
    while(!q.empty())
    {
        int t=q.front();
        q.pop();
        for(int i=0;i&lt;2;i++)
        {
            if(ac[t].nxt[i])
            {
                ac[ac[t].nxt[i]].fail=ac[ac[t].fail].nxt[i];
                q.push(ac[t].nxt[i]);
            }
            else ac[t].nxt[i]=ac[ac[t].fail].nxt[i];
            if(ac[ac[t].fail].nd)ac[t].nd=1;
        }
    }
}
int vis[32500];
int acn[32099];
void dfs(int d)
{  
    vis[d]=1;
    for(int i=0;i&lt;=1;i++) 
        if(vis[ac[d].nxt[i]])
        { 
            printf(&quot;TAK&quot;);
            exit(0); 
        }
        else if(ac[ac[d].nxt[i]].nd==0&amp;&amp;acn[ac[d].nxt[i]]==0)
        {
            acn[ac[d].nxt[i]]=1;
            dfs(ac[d].nxt[i]);
        }
    vis[d]=0; 
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%s&quot;,ch);
        add(ch);
    }
    find_fail();
    dfs(0);
    printf(&quot;NIE&quot;);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> luogu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POI </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[luogu3420(POI)]]></title>
      <url>/2017/10/10/luogu3420-POI/</url>
      <content type="html"><![CDATA[<p>POI中的大大大水题，做法很多，最最麻烦的可以tarjan缩点之后判断有多少入度为0的点，简单的话可以直接深搜，反正我是随手敲了一个并查集，因为错误的数据范围WA了一次然后1A。</p>
<p><strong>注意：本题不能只开100000的数组！！！</strong></p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt; 
using namespace std;
int fa[1000005];
int n;
int gef(int x)
{
    if(fa[x]==x)return x;
    else return fa[x]=gef(fa[x]);
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
        fa[i]=i;
    int x;
    for(int i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;x);
        int fx=gef(x);
        int y=gef(i);
        if(fx!=y)fa[y]=fx;
    }
    int ans=0;
    for(int i=1;i&lt;=n;i++)
        if(fa[i]==i)ans++;
    printf(&quot;%d&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> luogu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> POI </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj3683]]></title>
      <url>/2017/10/10/poj3853/</url>
      <content type="html"><![CDATA[<p>昨天做这道题的时候各种错误，今天早上终于调好了。原来也刷过几道2-sat的题，不过输出方案的这是第一道。本来2-sat输出方案的传统做法是先缩点，再建反图拓扑排个序，然后再染色，将红色点输出，然而昨天查资料的时候发现，其实在tarjan求强连通的时候，每个强联通分量的求出顺序就是原图的逆拓扑序！所以我们根本就不用再拓扑排序。接着，根据对称性，若原题有解的话，根据2-sat的对称性，我们只需在两个对应点之间找所属强连通分量时间戳更小的就行了，这样得出的就一定是一组可行解。</p>
<p><a href="http://poj.org/problem?id=3683" target="_blank" rel="external">题目链接</a>。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;stack&gt;
using namespace std;
int n;
int tot,had[3000],nxt[5000000],point[5000000];
struct wed{
    int bg;
    int nd;
}p[2003];
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
}
bool vis[3000];
int t;
int timel;
int dfn[3000],low[3000];
int blng[3000];//强连通分量时间戳 
stack&lt;int&gt;ss;
int ans[2009];
void tarjan(int x)
{
    dfn[x]=low[x]=++t;
    vis[x]=t;
    ss.push(x);
    for(int i=had[x];i;i=nxt[i])
    {
        int to=point[i];
        if(!dfn[to])
        {
            tarjan(to);
            low[x]=min(low[x],low[to]);
        }
        else if(vis[to]) low[x]=min(low[x],dfn[to]);
    }
    if(low[x]==dfn[x])
    {
        timel++;
        while(!ss.empty())
        {
            int y=ss.top();
            vis[y]=0;
            ss.pop();
            blng[y]=timel;
            if(y==x)break;
        }
    }
}
int main()
{
    cin&gt;&gt;n;
    for(int  i=0;i&lt;n;i++)//处理读入 
    {
        int x1,x2,y1,y3,len;
        char c;
        cin&gt;&gt;x1&gt;&gt;c&gt;&gt;x2;
        cin&gt;&gt;y1&gt;&gt;c&gt;&gt;y3&gt;&gt;len;
        p[i&lt;&lt;1].bg=x1*60+x2;
        p[i&lt;&lt;1].nd=p[i&lt;&lt;1].bg+len;
        p[(i&lt;&lt;1)+1].bg=y1*60+y3-len;
        p[(i&lt;&lt;1)+1].nd=p[(i&lt;&lt;1)+1].bg+len;
    }
    for(int i=0;i&lt;2*n;i++)//建图 
        for(int j=i+1;j&lt;2*n;j++)
            if(p[i].bg&gt;=p[j].bg&amp;&amp;p[i].bg&lt;p[j].nd)
            {
                add(i,j^1);
                add(j,i^1);
            }
            else
                if(p[j].bg&gt;=p[i].bg&amp;&amp;p[j].bg&lt;p[i].nd)
                {
                    add(j,i^1);
                    add(i,j^1);
                }
    for(int i=0;i&lt;2*n;i++)//tarjan缩点 
        if(!dfn[i])tarjan(i);
    for(int i=0;i&lt;2*n;i+=2)//判断是否有解 
        if(blng[i]==blng[i+1])
        {
            cout&lt;&lt;&quot;NO&quot;;
            return 0;
        }
    for(int i=0;i&lt;2*n;i+=2)//在对应点中选取所属时间戳小的 
        if(blng[i]&lt;blng[i+1])ans[i/2]=i;
        else ans[i/2]=i+1;
    cout&lt;&lt;&quot;YES\n&quot;;
    for(int i=0;i&lt;n;i++)//处理并输出 
        printf(&quot;%02d:%02d %02d:%02d\n&quot;,p[ans[i]].bg/60,p[ans[i]].bg%60,p[ans[i]].nd/60,p[ans[i]].nd%60);
    return 0;
}
</code></pre>
<p>这题还有一个坑点就是若一场婚礼的结束时间与下一场婚礼的开始时间是一样的的话，我们认为这不冲突。为了这个WA了一次。。。</p>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2-sat总结]]></title>
      <url>/2017/10/10/2-sat%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>到今天总算是刷完了poj的6道2-sat，在这里做个纪念。</p>
<p>2-sat的本质就是给你n个布尔变量和m个限制，限制一共有四种格式：</p>
<pre><code>若A为真，则B必为真
若A为真，则B必不为真
若A为假，则B必为假
若A为假，则B必为真
</code></pre><p>一般要求求出是否可同时满足这m个限制，或是求出一组同时满足这些限制的解。</p>
<p>一般的解法是，对于每个布尔变量ai，我们把它拆成两个点ai和ai’，分别代表为真和为假的状态。于是原题就变成了在2n个点中选取n个点。</p>
<p>然后对于上述4种限制，我们可以转换并连边为</p>
<pre><code>若选A，则必选B  (从A到B连边)
若选A，则必选B* (从A到B*连边)
若选A*，则必选B*(从A*到B*连边)
若选A*，则必选B (从A*到B连边)
</code></pre><p>同时需要注意到，由于每个变量只可能同时有一个状态（即2-sat的对称性），当我们连了一条A到B’的边时，我们还必须连一条B到A’的边。因为选A就必须选B，若选了B’再选A的话我们还要选B，而B和B’是无法同时选的。其他的连边类似。</p>
<p>特殊的，在某种情况下我们会遇到必须选A的情景。这时候我们可以连一条由A’到A的边，限制住必须选A。</p>
<p>将边都连完后，我们就得到了一张有向图，这张图中可能一些环，因此我们需要缩点。我们用tarjan求出所有的强连通分量，易得在同一个强连通分量中的点要么同时都选，要么同时都不选。因此我们只要看一下有没有对应点存在于同一个强连通分量中即可判断是否有解（因为每对对应点都必须选且只能选一个）。</p>
<p>对于要求输出一组解的情况，一般的方法是对已缩完点的图建立反图，对反图进行拓扑排序然后染色，将出度为0的点染成红色，并将它们的对应点以及其前驱都染成蓝色，当所有点都染色完毕后，所有红色的点就是一组解。</p>
<p>然而还有更简便的方法：当我们用tarjan进行缩点的时候，所有强连通分量求出的顺序就是原图的逆拓扑序，由此我们省略了建立反图和拓扑排序。再者，根据2-sat的对称性，对于每一对对应点我们都选所在联通块时间戳更小的，这样对于大的那个点，其前驱必定是所在点对中时间戳大的。这样，我们只需一遍tarjan即可求出一组解。</p>
<p>对于一些题目，要求求出字典序最小的点。对于这样的题目，我们无法缩点解决，似乎唯一可行的方案就是爆搜。。。不过poj的六道题中是没有这样的题的。</p>
<blockquote>
<p>PS:对于2-sat的一些更专业的介绍和对称性的证明可以参考《由对称性解2-SAT问 题》（伍昱）和《2-SAT解法浅析》（赵爽）</p>
</blockquote>
<p>附上poj上的6到题以及我的渣题解</p>
<p><a href="http://poj.org/problem?id=3207" target="_blank" rel="external">poj3207</a></p>
<p><a href="http://poj.org/problem?id=3678" target="_blank" rel="external">poj3678</a>————<a href="https://butwedo.space/2017/09/21/poj3678_poj3207/">poj3207、poj3678题解</a></p>
<p><a href="http://poj.org/problem?id=2723" target="_blank" rel="external">poj2723</a>———— <a href="https://butwedo.space/2017/09/21/poj2723/">题解</a></p>
<p><a href="http://poj.org/problem?id=3683" target="_blank" rel="external">poj3683</a>———— <a href="https://butwedo.space/2017/09/19/poj3683/">题解</a></p>
<p><a href="http://poj.org/problem?id=3648" target="_blank" rel="external">poj3648</a>————  <a href="https://butwedo.space/2017/09/19/poj3648/">题解</a></p>
<p><a href="http://poj.org/problem?id=2749" target="_blank" rel="external">poj2749</a>———— <a href="https://butwedo.space/2017/09/21/poj2749/">题解</a></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj3522]]></title>
      <url>/2017/10/10/poj3522/</url>
      <content type="html"><![CDATA[<p>一道对于最小生成树算法的很不错的应用。</p>
<p>题目要求是给你一张图，求一棵树，要求其 <strong>最大边与最小边的差值</strong> 最小。</p>
<p>考虑kruskal算法，排序之后我们枚举最小界，然后每次构建最小生成树可以得到最大边，然后不断地更新答案就好了。</p>
<p><a href="http://poj.org/problem?id=3522" target="_blank" rel="external">poj3522</a></p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
struct dou{
    int x,y;
    int w;
}l[10004];
int fa[103];
bool cmp(dou x,dou y)
{
    return x.w&lt;y.w;
}
int gef(int x)
{
    if(fa[x]==x)return x;
    return fa[x]=gef(fa[x]);
}
int n,m;
int main()
{
    while((~scanf(&quot;%d%d&quot;,&amp;n,&amp;m))&amp;&amp;n)
    {
        for(int i=1;i&lt;=m;i++)
            scanf(&quot;%d%d%d&quot;,&amp;l[i].x,&amp;l[i].y,&amp;l[i].w);
        sort(l+1,l+1+m,cmp);
        int big=l[m].w;
        for(int i=1;i&lt;=m;i++)
        {
            int j,k;
            for(j=1;j&lt;=n;j++)
                fa[j]=j;
            for(j=i;j&lt;=m;j++)
            {
                int x=gef(l[j].x);
                int y=gef(l[j].y);
                if(x!=y) 
                {
                    fa[x]=y;
                    k=j;
                }
            }
            int sum=0;
            for(int j=1;j&lt;=n;j++)
            {
                fa[j]=gef(fa[j]);
                if(fa[j]==j)sum++;
            }
            if(sum!=1)break;
            big=min(big,l[k].w-l[i].w);
        }
        if(big==l[m].w)big=-1;
        printf(&quot;%d\n&quot;,big);
    }
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bzoj1034]]></title>
      <url>/2017/10/09/bzoj1034/</url>
      <content type="html"><![CDATA[<p>应该是改编自USACO的田忌赛马？最好的情况好处理，直接套用田忌赛马思想，排序后从小的开始比较，可以比过就加分，不行的话再看最大的能不能比过，能就加分，如果都不行那就用自己最弱的去怼掉对方最强的。对于最坏的情况很明显我们能看出就是对手最好的情况，所以我们按照刚才的策略对对手进行一波贪心，由于不管谁输谁赢或是平局，一局对两人带来的分数总和都是2，所以我们只要用n*2-对手的最优即可得到己方的最坏情况。</p>
<p>题目链接：<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1034" target="_blank" rel="external">bzoj1034</a></p>
<p>渣代码：</p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
using namespace std;
int n,ans;
int zj[100005],ds[100005];
int solve(int zj[],int ds[])
{
    int zi=1,di=1;
    int zn=n,dn=n;
    int m=n;
    int ans=0;
    while(m--)
    {
        if(zj[zi]&gt;ds[di])
        {
            ans+=2;
            zi++;
            di++;
        }
        else if(zj[zn]&gt;ds[dn])
        {
            ans+=2;
            zn--;
            dn--;
        }
        else 
        {
            ans+=(zj[zi]==ds[dn]);
            zi++;
            dn--;
        }
    }
    return ans;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;zj[i]);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%d&quot;,&amp;ds[i]);
    sort(zj+1,zj+n+1);
    sort(ds+1,ds+n+1);
    printf(&quot;%d %d&quot;,solve(zj,ds),2*n-solve(ds,zj));
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> bzoj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 水题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj2060]]></title>
      <url>/2017/10/08/poj2060/</url>
      <content type="html"><![CDATA[<p>有n个任务，给出任务时间和起点终点，每两个点之间的时间花费为其曼哈顿距离，问若要每个任务都按时开始需要多少出租车。</p>
<p>并不是很难，就是题意理解起来可能会有些问题，反正我当时是WA了几遍之后才发现的，a到b能连边，需满足a的开始时间+到终点花费+从a的终点到b的起点的花费&lt;=b的开始时间<br>将图建好之后就简单了，直接跑一遍匈牙利求最小路径覆盖=总点数-最大匹配即可。</p>
<p>还get到了一个scanf的新用法：<code>scanf(&quot;%d:%d&quot;,&amp;a,&amp;b)</code>可以直接跳过去中间的’:’直接读入b，当时用的getchar还RE了几遍，用这个就AC了QAQ</p>
<p>附上题目链接：<a href="http://poj.org/problem?id=2060" target="_blank" rel="external">poj2060</a></p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int tot;
int had[1030],point[500*500+2],nxt[500*500+2];
int fa[1004];
bool vis[1003];
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
}
bool cando(int x)
{
    for(int i=had[x];i;i=nxt[i])
    {
        int to=point[i];
        if(!vis[to])
        {
            vis[to]=1;
            if(fa[to]==0||cando(fa[to]))
            {
                fa[to]=x;
                return 1;
            }
        }
    }
    return 0;
}
int n,m,t;
struct dou{
    int stt,nd;
    int s1,s2,e1,e2;
}p[504];
inline int ab(int x)
{
    if(x&lt;0)return -x;
    return x;
}
inline bool line(int x,int y)
{
    int dis=ab(p[x].e1-p[y].s1)+ab(p[x].e2-p[y].s2);
    if(p[x].nd+dis&lt;p[y].stt)return 1;
    return 0;
}
int main()
{
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        tot=0;
        int day=0;
        memset(fa,0,sizeof(fa));
        memset(had,0,sizeof(had));
        int a,b;
        for(int i=1;i&lt;=n;i++)
        {
            scanf(&quot;%d:%d&quot;,&amp;a,&amp;b);
            p[i].stt=a*60+b;
            scanf(&quot;%d%d%d%d&quot;,&amp;p[i].s1,&amp;p[i].s2,&amp;p[i].e1,&amp;p[i].e2);
            p[i].nd=p[i].stt+ab(p[i].s1-p[i].e1)+ab(p[i].s2-p[i].e2);
            while(p[i].stt&lt;p[i-1].stt)
            {
                p[i].stt+=24*60;
                p[i].nd+=24*60;
            }
        }
        for(int i=1;i&lt;=n;i++)
            for(int j=i+1;j&lt;=n;j++)
                if(line(i,j))add(i,j+n);
    //    for(int i=1;i&lt;=n;i++)
    //        cout&lt;&lt;p[i].stt&lt;&lt;&#39; &#39;&lt;&lt;p[i].nd&lt;&lt;endl;
        int ans=0;
        for(int i=1;i&lt;=n;i++)
        {
            memset(vis,0,sizeof(vis));
            if(cando(i))ans++;
        }
        printf(&quot;%d\n&quot;,n-ans);
    }
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj2226]]></title>
      <url>/2017/10/08/poj2226/</url>
      <content type="html"><![CDATA[<p>一道很经典的题，因为一块儿泥地可以被横着的木板覆盖也可以被竖着的木板覆盖，所以对于每个联通块我们横纵坐标分别标号，然后连接对应的横纵标号建图，求一遍最小覆盖即可。</p>
<p><a href="http://poj.org/problem?id=2226" target="_blank" rel="external">poj2226题目链接</a></p>
<p>贴出渣代码：</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
using namespace std;
char c[100][100];
int f[100][100];
int n,m;
int fa[1000];
bool vis[1000];
int tot;
int had[1000],nxt[160004],point[160004];
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
}
bool cando(int x)
{
    for(int i=had[x];i;i=nxt[i])
    {
        int to=point[i];
        if(!vis[to])
        {
            vis[to]=1;
            if(fa[to]==0||cando(fa[to]))
            {
                fa[to]=x;
                return 1;
            }
        }
    }
    return 0;
}
int ns,ms;
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        scanf(&quot;%s&quot;,c[i]+1);
    int ans=0;
    for(int i=1;i&lt;=n;i++)
    {
        int t=0;
        for(int j=1;j&lt;=m;j++)
            if(t==0&amp;&amp;c[i][j]==&#39;*&#39;)
            {
                ns++;
                f[i][j]=ns;
                t=1;
            }
            else
            {
                if(t==1&amp;&amp;c[i][j]==&#39;*&#39;)
                    f[i][j]=ns;
                if(t==1&amp;&amp;c[i][j]==&#39;.&#39;)
                    t=0;
            }
    }
    for(int i=1;i&lt;=m;i++)
    {
        int t=0;
        for(int j=1;j&lt;=n;j++)
            if(t==0&amp;&amp;c[j][i]==&#39;*&#39;)
            {
                ms++;
                add(f[j][i],ms);
                t=1;
            }
            else
            {
                if(t==1&amp;&amp;c[j][i]==&#39;*&#39;)
                    add(f[j][i],ms);
                if(t==1&amp;&amp;c[j][i]==&#39;.&#39;)
                    t=0;
            }
    }
    for(int i=1;i&lt;=ns;i++)
    {
        memset(vis,0,sizeof(vis));
        if(cando(i))ans++;
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 二分图 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj3678/poj3207]]></title>
      <url>/2017/09/21/poj3678_poj3207/</url>
      <content type="html"><![CDATA[<p>两道入门的2-sat，只要判定是否有解即可。</p>
<h3 id="poj3678"><a href="#poj3678" class="headerlink" title="poj3678"></a>poj3678</h3><hr>
<p> <a href="http://poj.org/problem?id=3278" target="_blank" rel="external">题目链接</a><br> 直接读入然后按照题目要求和位运算规则建图即可，不多解释。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;stack&gt;
using namespace std;
int dfn[100002],low[100002];
int tot,had[100002],nxt[4000006],point[4000006];
int blng[100002];
int t;
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
} 
bool vis[1003];
stack&lt;int&gt;s;
void tarjan(int x)
{
    low[x]=dfn[x]=++t;
    vis[x]=1;
    s.push(x);
    for(int i=had[x];i;i=nxt[i])
    {
        int to=point[i];
        if(!dfn[to])
        {
            tarjan(to);
            low[x]=min(low[x],low[to]);
        }
        else if(vis[to])
        {
            low[x]=min(low[x],dfn[to]);
        }
    }
    if(dfn[x]==low[x])
    {
        int y;
        while(!s.empty())
        {
            y=s.top();
            s.pop();
            vis[y]=0;
            blng[y]=x;
            if(y==x)break;
        }
    }
}
int main()
{
    int n,m;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++)
    {
        int a,b,c;
        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
        a++;b++;
        char ch[10];
        scanf(&quot;%s&quot;,ch);
        if(!strcmp(ch,&quot;AND&quot;))
        {
            if(c==0)
            {
                add(a+n,b);
                add(b+n,a);
            }
            else
            {
                add(a,a+n);
                add(b,b+n);
                add(a+n,b+n);
                add(b+n,a+n);
            }
        }
        if(!strcmp(ch,&quot;OR&quot;))
        {
            if(c==0)
            {
                add(a,b);
                add(b,a);
                add(a+n,a);
                add(b+n,b);
            }
            else
            {
                add(a,b+n);
                add(b,a+n);
            }
        }
        if(!strcmp(ch,&quot;XOR&quot;))
        {
            if(c==0)
            {
                add(a,b);
                add(b,a);
                add(a+n,b+n);
                add(b+n,a+n);
            }
            else
            {
                add(a,b+n);
                add(b+n,a);
                add(a+n,b);
                add(b,a+n);
            }
        }
    }
    for(int i=1;i&lt;=2*n;i++)
    {
        if(!dfn[i])tarjan(i);
    }
    for(int i=1;i&lt;=n;i++)
    {
        if(blng[i]==blng[i+n])
        {
            printf(&quot;NO&quot;);
            return 0;
        }
    }
    printf(&quot;YES&quot;);
    return 0;
}
</code></pre>
<h3 id="poj3207"><a href="#poj3207" class="headerlink" title="poj3207"></a>poj3207</h3><hr>
<p><a href="http://poj.org/problem?id=3207" target="_blank" rel="external">题目链接</a></p>
<p>在围成一个圈的点之间连边，边不能与圈交叉，即要么全在里面要么全在外面。将所有的边读进来之后，将边的编号拆点，若两条边可能交叉就对应连边建图。之后判定即可。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;stack&gt;
#include&lt;cstring&gt;
using namespace std;
const int big=1000002;
int dfn[big],low[big];
int tot,n,m;
int t;
int had[big],nxt[big],point[big];
bool vis[big];
int blng[big];
int l[big];
int r[big];
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
}
stack&lt;int&gt; sk;
void tarjan(int x)
{
    dfn[x]=low[x]=++t;
    vis[x]=1;
    sk.push(x);
    for(int i=had[x];i;i=nxt[i])
    {
        int to=point[i];
        if(!dfn[to])
        {
            tarjan(to);
            low[x]=min(low[x],low[to]);
        }
        else if(vis[to])low[x]=min(low[x],dfn[to]);
    }
    if(low[x]==dfn[x])
    {
        int y;
        while(!sk.empty())
        {
            y=sk.top();
            sk.pop();
            vis[y]=0;
            blng[y]=x;
            if(y==x)break;
        }
    }
}
int main()
{
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        r[i]=r[i+m]=max(a,b)+1;
        l[i]=l[i+m]=min(a,b)+1; 
    }
    for(int i=1;i&lt;m;i++)
        for(int j=1+i;j&lt;=m;j++)
        {
            if(r[i]&gt;=l[j]&amp;&amp;r[i]&lt;=r[j]&amp;&amp;l[i]&lt;=l[j])
            {
                add(i,j+m);
                add(j,i+m);
                add(j+m,i);
                add(i+m,j);
            }
            if(r[j]&gt;=l[i]&amp;&amp;r[i]&lt;=r[j]&amp;&amp;l[i]&lt;=l[j])
            {
                add(i,j+m);
                add(j,i+m);
            }
        }
    for(int i=1;i&lt;=2*m;i++)
    {
        if(!dfn[i])tarjan(i);
    }
    bool f=1;
    for(int i=1;i&lt;=m;i++)
    {
        if(blng[i]==blng[i+m])
        {
            f=0;
            break;
        }
    }
    if(f)cout&lt;&lt;&quot;panda is telling the truth...&quot;;
    else cout&lt;&lt;&quot;the evil panda is lying again&quot;;
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj2749]]></title>
      <url>/2017/09/21/poj2749/</url>
      <content type="html"><![CDATA[<p>poj六道2-sat中的最后一道。事实上也算比较基础的，不用输出方案，只是建图的时候要多注意一些。</p>
<p><a href="http://poj.org/problem?id=2749" target="_blank" rel="external">题目链接</a></p>
<p>大意是给你两个源点，有n个点要向这两个点中的一个连边，边长为他们的曼哈顿距离，其中有的点必须连同一个源点，有的点必须连不同的源点。两个源点之间有边。给出两个源点和这n个点的坐标，要求使这n个点中任意两点之间的边长（点到源点再到点的边长）尽可能的小。</p>
<p>由于“最小化最长的连边”具有单调性，我们可以二分答案。每次二分时重新建图，将边长大于答案的边所连的两个点连（2-sat所成图中的）边。可行的话再向下二分，否则向上二分。</p>
<p>自己调了一个下午的代码老是不对，连样例都过不去。后来参考网上的题解还是不行，最后还是同机房的dalao帮忙找出了错，不止一个还一个比一个智障。。。。</p>
<p>放上渣代码(捂脸)</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
#include&lt;algorithm&gt;
#include&lt;cmath&gt;
using namespace std;
int had[1003],nxt[500000],point[500000];
int tot;
int sdis;
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
}
int t,timel;
int dfn[1002],low[1004];
stack&lt;int&gt;ss;
bool vis[1003];
int dis1[5090],dis2[5090];
int blng[1002];
int hate[5009][2];
int like[5009][2];
void tarjan(int u) 
{
    int v,i;
    dfn[u]=low[u]=++t;
    vis[u]=1;
    ss.push(u);
    for(i=had[u];i;i=nxt[i]) 
    {
        v=point[i];
        if(!dfn[v]) 
        {
            tarjan(v);
            low[u]=min(low[u],low[v]);
        } 
        else if(vis[v]) 
            low[u]=min(low[u],dfn[v]);
    }
    if(dfn[u] == low[u]) 
    {
        timel++;
        do 
        {
            v=ss.top();
            ss.pop();
            blng[v]=timel;
            vis[v]=false;
        } while(v!=u);
    }
}
int n,lk,ht;
int big;
void build(int lim) 
{
    int i,j,x,y;
    for(i=0;i&lt;ht;i++) 
    {
        x=hate[i][0]*2; 
        y=hate[i][1]*2;
        add(x,y+1); 
        add(y,x+1);
        add(y+1,x); 
        add(x+1,y);
    }
    for(i=0;i&lt;lk;i++) 
    {
        x=like[i][0]*2;
        y=like[i][1]*2;
        add(x,y); 
        add(x+1,y+1);
        add(y,x); 
        add(y+1,x+1);
    }
    for(i=0;i&lt;n;i++) 
        for(j=i+1;j&lt;n;j++) 
        {
            x=i&lt;&lt;1;
            y=j&lt;&lt;1;
            if(dis1[i]+dis1[j]&gt;lim)     
            {
                add(x,y+1);
                add(y,x+1);
            }
            if(dis2[i]+dis2[j]&gt;lim)    
            {
                add(x+1,y);
                add(y+1,x);
            }
            if(dis1[i]+dis2[j]+sdis&gt;lim)    
            {
                add(x,y);
                add(y+1,x+1);
            }
            if(dis2[i]+dis1[j]+sdis&gt;lim) 
            {    
                add(x+1,y+1);
                add(y,x);
            }
        }
}
bool cando()
{
    for(int i=0;i&lt;2*n;i+=2)
        if(blng[i]==blng[i+1])
            return 0;
    return 1;
}
bool solve(int lim)
{
    memset(blng,0,sizeof(blng));
    memset(dfn,0,sizeof(dfn));
    memset(low,0,sizeof(low));
    tot=0;
    timel=0;
    t=0;
    memset(had,0,sizeof(had));
    memset(point,0,sizeof(point));
    memset(nxt,0,sizeof(nxt));
    build(lim);
    for(int i=0;i&lt;2*n;i++)
        if(!dfn[i])tarjan(i);
    for(int i=0;i&lt;2*n;i+=2)
        if(blng[i]==blng[i+1])
            return 0;
    return 1;
}
int main()
{
    cin&gt;&gt;n&gt;&gt;ht&gt;&gt;lk;
    int x1,x2,y1,y2;
    cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
    sdis=abs(x1-x2)+abs(y1-y2);
    for(int i=0;i&lt;n;i++) 
    {
        int x,y;
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
        dis1[i]=abs(x-x1)+abs(y-y1);
        dis2[i]=abs(x-x2)+abs(y-y2);
        big=max(big,max(dis1[i],dis2[i]));
    }
    for(int i=0;i&lt;ht;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        a--;
        b--;
        hate[i][0]=a;
        hate[i][1]=b;
    }
    for(int i=0;i&lt;lk;i++)
    {
        int a,b;
        cin&gt;&gt;a&gt;&gt;b;
        a--;
        b--;
        like[i][0]=a;
        like[i][1]=b;
    }
    int l=0, r=big*3,mid,ans=-1;
    while(l&lt;=r) 
    {
        mid=(l+r)&gt;&gt;1;
        if(solve(mid))    
        {
            ans=mid;
            r=mid-1;
        }
        else l=mid+1;
    }
    cout&lt;&lt;ans;
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj2723]]></title>
      <url>/2017/09/21/poj2723/</url>
      <content type="html"><![CDATA[<p>一道很基础的2-sat，题目链接戳<a href="http://poj.org/problem?id=2723" target="_blank" rel="external">这里</a>。</p>
<p>大意是，你有n对钥匙，每对钥匙中只能选一个。你要开m个门，每个门可以用两把给定钥匙中的任意一把打开，问你最多能开到第几道门。</p>
<p>为了方便处理，我们先做个映射，把第i对钥匙的编号转换为<br><code>i*2</code>和<code>i*2+1</code>。然后将门当做限制连边，每读入一个就连一条边，判定是否可行，直到不可行为止。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;stack&gt;
using namespace std;
int mp[10000]; 
int tot;
int had[5050],nxt[5000],point[5005];
int t;
int dfn[20000],low[20000];
int blng[20000];
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
}
stack&lt;int&gt; ss;
bool vis[20000];
void tarjan(int x)
{
    t++;
    dfn[x]=low[x]=t;
    vis[x]=1;
    ss.push(x);
    for(int i=had[x];i!=-1;i=nxt[i])
    {
        int to=point[i];
        if(!dfn[to])
        {
            tarjan(to);
            low[x]=min(low[x],low[to]);
        }
        else if(vis[to])low[x]=min(low[x],dfn[to]);
    }
    if(low[x]==dfn[x])
    {
        int y=ss.top();
        while(!ss.empty())
        {
            y=ss.top();
            ss.pop();
            blng[y]=x;
            vis[y]=0;
            if(y==x)break;
        }
    }
}
int main()
{
    int n,m;
    while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n)
    {
        tot=0;
        memset(had,-1,sizeof(had));
        memset(nxt,-1,sizeof(nxt));
        memset(point,-1,sizeof(point));
        for(int i=0;i&lt;n;i++)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            mp[a]=2*i;
            mp[b]=2*i+1; 
        }
        bool f=0;
        for(int i=1;i&lt;=m;i++)
        {
            int a,b;
            cin&gt;&gt;a&gt;&gt;b;
            if(f)continue;
            add(mp[a],mp[b]^1);
            add(mp[b],mp[a]^1);
            t=0;
            memset(dfn,0,sizeof(dfn));
            memset(low,0,sizeof(low));
            memset(vis,0,sizeof(vis));
            memset(blng,0,sizeof(blng));
            for(int j=0;j&lt;2*n;j++)
                if(!dfn[j])tarjan(j);
            for(int j=0;j&lt;2*n;j+=2)
                if(blng[j]==blng[j+1])
                {
                    cout&lt;&lt;i-1&lt;&lt;endl;
                    f=1;
                    break;
                }
        }
        if(f==0)cout&lt;&lt;m&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[bzoj1013]]></title>
      <url>/2017/09/20/bzoj1013/</url>
      <content type="html"><![CDATA[<p>本来是打算这两天一口气刷完poj的6到2-sat的，但昨天的模拟赛被一道题高斯消元直接虐了3个半小时没调出来，后来发现自己的高斯消元的板子就是错的= =。。</p>
<p>今天决定更新一下板子，就参照着<a href="http://hzwer.com/1981.html" target="_blank" rel="external">黄学长的博客</a>打了一下这道题WA了几遍总算AC了，没什么大问题。</p>
<p>照例丢<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=1013" target="_blank" rel="external">链接</a>.</p>
<p>这道题题目大意是说给你一个n维空间球上的n+1个点，让你求球心坐标。只要处理一下输入就变成了一道高斯消元的模板题。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cmath&gt;
using namespace std;
double gs[20][20];
double f[20];
int n;
int main()
{
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
        cin&gt;&gt;f[i];
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=n;j++)
        {
            double a;
            cin&gt;&gt;a;
            gs[i][j]=2*a-2*f[j];
            gs[i][n+1]+=a*a;
            gs[i][n+1]-=f[j]*f[j];
        }
    //对于读入的处理：
    //我们通过n个坐标列距离公式，拆开再合并可以列出n个多项式
    //再通过剩下的那个坐标构建等式，移项消元构建方程。 
    for(int i=1;i&lt;=n;i++)
    {
        int big=0,mn;
        for(int j=1;j&lt;=n;j++)
            if(fabs(gs[i][j])&gt;big&amp;&amp;gs[i][j]!=0)
            {
                big=gs[i][j];
                mn=j;
            }
        if(mn!=i)
            for(int j=1;j&lt;=n+1;j++)
                swap(gs[i][j],gs[mn][j]);
        for(int j=1;j&lt;=n;j++)
        {
            if(j==i)continue;
            double a=gs[j][i]/gs[i][i];
            for(int k=1;k&lt;=n+1;k++)
                gs[j][k]-=gs[i][k]*a;
        }
    }
    for(int i=1;i&lt;n;i++)
        printf(&quot;%.3lf &quot;,gs[i][n+1]/gs[i][i]);
    printf(&quot;%.3lf&quot;,gs[n][n+1]/gs[n][n]);
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> bzoj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 高斯消元 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poj3648]]></title>
      <url>/2017/09/19/poj3648/</url>
      <content type="html"><![CDATA[<p>一天之内完成两道2-sat，新方法就是霸气~</p>
<p>这道题的题目大意是一对新人要举行婚礼，邀请了n对夫妇在宴席上有这么些奇奇怪怪的风俗：一对夫妇不能做同一侧否则会有厄运；除此之外还有一些有暧昧关系的人，这些人不能同时被新娘看到，否则也会有厄运。问是否有解，若有的话输出任意一组。</p>
<p>这是<a href="http://poj.org/problem?id=3648" target="_blank" rel="external">题目链接</a>。</p>
<p>以坐在新郎一侧的人是谁为对应点建图，记录新郎一侧的解，输出的时候反过来。不直接记录新娘一侧的点是因为据discuss说新娘也可能有暧昧关系。。。。。。然后还有一点就是要连一条新娘到新郎的边，表示新郎一定要选（因为是求新郎一侧的解）。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;stack&gt; 
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int tot;
int had[200],nxt[40004],point[40004];
inline void add(int x,int y)
{
    tot++;
    point[tot]=y;
    nxt[tot]=had[x];
    had[x]=tot;
}
int t,timel;
int dfn[200],low[200],blng[200];
bool vis[200];
stack&lt;int&gt;ss;
void tarjan(int x)
{
    dfn[x]=low[x]=t++;
    ss.push(x);
    vis[x]=1;
    for(int i=had[x];i;i=nxt[i])
    {
        int to=point[i];
        if(!dfn[to])
        {
            tarjan(to);
            low[x]=min(low[x],low[to]);
        }
        else
        if(vis[to])low[x]=min(low[x],dfn[to]);
    }
    if(dfn[x]==low[x])
    {
        timel++;
        while(!ss.empty())
        {
            int y=ss.top();
            blng[y]=timel;
            vis[y]=0;
            ss.pop();
            if(y==x)break;
        }
    }
}
int n,m;
int main()
{
    while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n)
    {    
        tot=0;
        t=0;
        timel=0;
        bool f=0;
        memset(dfn,0,sizeof(dfn));
        memset(low,0,sizeof(low));
        memset(had,0,sizeof(had));
        memset(nxt,0,sizeof(nxt));
        memset(blng,0,sizeof(blng));    
        memset(point,0,sizeof(point));
        for(int i=0;i&lt;m;i++)
        {
            int w,h;
            char w1,h1;
            cin&gt;&gt;w&gt;&gt;w1;
            cin&gt;&gt;h&gt;&gt;h1;
            w&lt;&lt;=1;
            h&lt;&lt;=1;
            if(w1==&#39;h&#39;)w++;
            if(h1==&#39;h&#39;)h++;
            add(w,h^1);
            add(h,w^1);
        }
        add(0,1); 
        for(int i=0;i&lt;2*n;i++)
            if(!dfn[i])tarjan(i);
        for(int i=0;i&lt;2*n;i+=2)
            if(blng[i]==blng[i+1])
            {
                f=1;
                cout&lt;&lt;&quot;bad luck\n&quot;;
                break;
            }
        if(f)continue;
        for(int i=2;i&lt;2*n;i+=2)
        {
            cout&lt;&lt;(i&gt;&gt;1);
            if(blng[i]&lt;blng[i+1])cout&lt;&lt;&quot;h &quot;;
            else cout&lt;&lt;&quot;w &quot;;
        }
        cout&lt;&lt;endl;
    }
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> poj </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 2-SAT </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一个有点意思的证明]]></title>
      <url>/2017/09/15/%E4%B8%80%E4%B8%AA%E6%8C%BA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E8%AF%81%E6%98%8E/</url>
      <content type="html"><![CDATA[<p>昨天二师兄突然来这边机房，然后又突然就没头没脑的提出了这个问题：</p>
<blockquote>
<p>将一个完全图的所有边任意指定方向（所谓竞赛图），如何证明这张图一定存在一条哈密顿路径？</p>
</blockquote>
<p>经过一番思考和操作，我们大致把它给搞出来了，现记录如下。</p>
<p>首先证明，一个竞赛图最多存在一个入度为0的点：<br>若存在两个以上的点入度为零，那么它们之间的边无法指明方向，证毕。</p>
<p>然后我们要明确一点，即一个完全图删掉一个点及其所有连边之后还是一个完全图。那么我们一直删掉那个入度为零的点进行拓扑排序，递归证明可得每次删掉一个点之后最多还是只会有一个点入度为零，且这个点一定是上一个被删点的儿子节点（姑且这么叫）。一直删点直到没有点为止，我们一定能够求出一条哈密顿路。</p>
<p>那么如果途中不存在入度为零的点怎么办呢？</p>
<p>我们可以随意指定一个点，并且把指向它的边都删掉，这样就有了一个入度为零的点了（手动滑稽）。由于我们删掉的都是它的入边，因此不会把其他的点变为入度为零的点。<br>然后继续递归求解。证毕。</p>
]]></content>
      
        <categories>
            
            <category> 线下OI </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 证明 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[又是一道坑题HDU4405]]></title>
      <url>/2017/09/15/HDU4405/</url>
      <content type="html"><![CDATA[<p>最近打算刷几道概率DP，然而就这么状况频出。。。</p>
<p>丢个链接：</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4405" target="_blank" rel="external">HDU4405</a></p>
<p>这道题的大意是说Hzz玩儿飞行棋，起点是0，终点是n，并且路径上还有m条航线(x,y)可以不用掷骰子直接从x到y。问掷骰子次数的期望。</p>
<p>明明是一道裸题，结果又WA了好几遍。看讨论才发现若x点存在航线的话直接飞，不考虑掷骰子的事儿。然而原文中说的是</p>
<blockquote>
<p>The i-th flight line can help Hzz fly from grid Xi to Yi (0&lt;Xi&lt;Yi&lt;=N) without throwing the dice.</p>
</blockquote>
<p>我也不知道这个“help”咋就成强制的了，因为可能会存在这种情况：</p>
<pre><code>12 7
1 8
2 12
3 12
4 12
5 12
6 12
7 12
0 0
</code></pre><p>这样的数据，当第一次掷出1时很明显不选走航线是更优的。。。不是很明白飞行棋的规矩，但是按照题目里的说明应该是可以选择飞不飞吧。。。然而这么打就错了，强制飞就对了。。。辣鸡HDU。。。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
int n,m;
double f[100005];
int to[100005];
int main()
{
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF&amp;&amp;n)
    {
        memset(f,0,sizeof(f));
        memset(to,0,sizeof(to));
        for(int i=1;i&lt;=m;i++)
        {
            int a,b;
            scanf(&quot;%d%d&quot;,&amp;a,&amp;b);
            to[a]=b;
        }
        for(int i=n-1;i&gt;=0;i--)
        {
            for(int j=1;j&lt;=6;j++)
            {
                f[i]+=f[i+j];
                if(i+j==n)break; 
            }
            f[i]=f[i]/6.0+1;
            if(to[i])f[i]=min(f[i],f[to[i]]);
        }
        printf(&quot;%.4lf\n&quot;,f[0]);
    }
    return 0;
}
</code></pre>
]]></content>
      
        <categories>
            
            <category> hdu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> 期望DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDU3853 LOOPS]]></title>
      <url>/2017/09/14/LOOPS/</url>
      <content type="html"><![CDATA[<p>先丢个<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3853" target="_blank" rel="external">题目链接</a>。<br>题目大意是此主人公（马猴烧酒，话说前几天才和yzyun大佬谈论过这个梗= =）处在一个r*c的矩阵的左上角，她需要去到右下角，在每个点上，她有grid(r,c)的概率留在原地，有grid(r,c+1)的概率向右走，有grid(r+1,c)的1概率向下走，每次走动都需要花费2点能量值。求到终点的期望能量值花费。</p>
<p>一道很裸的期望DP，倒推期望，设f[i][j]为从点(i,j)到终点的期望，可推得，当s[i][j]不为1时，<code>f[i][j]=(f[i+1][j]*d[i][j]+f[i][j+1]*rm[i][j]+2)/(1-s[i][j])</code>，否则f[i][j]直接为0。一些变量的意义请直接见代码。</p>
<pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
double d[1003][1003],rm[1003][1003];//d代表向下的概率，rm代表向右的概率
double s[1003][1003],f[1003][1003];//s代表留在原地的概率，f代表期望花费
int main()
{
    int r,c;
    while(scanf(&quot;%d%d&quot;,&amp;r,&amp;c)!=EOF)
    {
        memset(f,0,sizeof(f));
        for(int i=1;i&lt;=r;i++)
        {
            for(int j=1;j&lt;=c;j++)
            {
                scanf(&quot;%lf%lf%lf&quot;,&amp;s[i][j],&amp;rm[i][j],&amp;d[i][j]);
            }
        }
        for(int i=r;i&gt;=1;i--)
        {
            for(int j=c;j&gt;=1;j--)
            {
                if(i==r&amp;&amp;j==c)continue;
                if(s[i][j]==1)continue;
                f[i][j]=(f[i+1][j]*d[i][j]+f[i][j+1]*rm[i][j]+2)/(1-s[i][j]);
            }
        }
        printf(&quot;%.3lf\n&quot;,f[1][1]);
    }
    return 0;
}
</code></pre>
<p>按理说这道题挺简单的，然而却有几个不大不小的槽点。这道题我第一遍交的时候按照每个点一组数据，数组开的float，结果WA了，第二遍开的double，按每个点多数据打的，然后就A了。。。不知道是精度问题还是hdu又一次不带提醒的用的多数据。。。。还有一个槽点的是答案保证不超过1000000，然而若中间的某点只能在原地走的话，期望就是INF，而我们把这样的点的期望赋值成了0，就相当于把这个点当成了又一个终点，可能会导致答案错误，不清楚数据是不是特意避开了这样的情况，还是标程就是错的没有考虑这种情况，反正我A了~如果有哪位dalao知道赋值为INF的正确做法的话，欢迎指出发到我邮箱里sounkix@outlook.com，非常感谢！</p>
]]></content>
      
        <categories>
            
            <category> hdu </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DP </tag>
            
            <tag> 期望DP </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>/about_me/index.html</url>
      <content type="html"><![CDATA[<blockquote>
<p><em>Let the rest be the tale they tell.</em></p>
</blockquote>
<p>现役OIer一枚，从初二开始搞OI，现在仍是初二水平。从高一开始就一直宣扬要从学校开始革命<del>不过从来不敢玩儿真的</del></p>
<p>曾经很喜欢Linkin Park，现在也很喜欢只是因为一些原因不太想听他们的歌了。从Linkin Park跳到了活结再跳到曼森再跳到夜愿，目前徘徊在各种黑金与死金与核中（<del>然而并不能分清各种风格</del>）。</p>
<p>每次在一群听着二次元音乐欧美流行和大陆情歌的dalao之间打代码的时候就会感到非常孤独。</p>
<p>喜欢变形金刚。入坑是因为TFP。</p>
<p>入TFP的坑是因为声波。</p>
<p>对于变形金刚的电影版只喜欢前3部，最喜欢第三部。</p>
<p>不喜欢4和5的原因是因为拍得烂而且柱子哥变丑了。<br>喜欢第三部是因为有震荡波。</p>
<p>家里有十几个模型了，总价大约是2000+。但大多是KO。</p>
<p><del>事实上这个总价也就能买个正版电影版的擎天柱</del></p>
<p>也很喜欢昆虫和文学，总之喜欢的东西没一个是和OI沾边的= =（然而这样也不能抑制我对OI的热爱？）</p>
<p>我也不知道写这个有什么用但自我介绍一下总是好的。</p>
<embed src="//music.163.com/style/swf/widget.swf?sid=28837241&type=2&auto=1&width=320&height=66" width="340" height="86" allownetworking="all">]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[friends and links]]></title>
      <url>/links/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[gallery]]></title>
      <url>/gallery/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
